{
  "users": [
    {
      "id": 1,
      "username": "Temirlan Suiumbek uulu",
      "passwordHash": "$2b$10$3hjkzdg2VjtwsIDcWQludebM.jUfq6vSicB4vwna78JW3UqtwSi06",
      "avatarUrl": "https://cdn-images-1.medium.com/fit/c/120/120/1*9ZtET_L1852yXaDZJUo9CQ.png",
      "bio": "Making software development more accessible ·  Teacher, OSS, GDE, @TC39 · @FrontendMasters @JavaScriptAir · #JS"
    },
    {
      "id": 2,
      "username": "john",
      "passwordHash": "$2b$10$eGtavxWlp1PwJ6VpZ4cTieDki738YPmDLndi1NckBkfEKrZ136jSS",
      "avatarUrl": "https://cdn-images-1.medium.com/fit/c/120/120/0*cmAOkoH29zoIVIBT",
      "bio": ""
    },
    {
      "id": 3,
      "username": "Dr.Strange",
      "passwordHash": "$2b$10$H9/HPH5Fb.sXtWFFdhB/Put0zcrhTPNZUcVLrrpTdsjW/Kzb141ry",
      "avatarUrl": "https://cdn-images-1.medium.com/fit/c/120/120/0*cmAOkoH29zoIVIBT",
      "bio": ""
    }
  ],
  "blogs": [
    {
      "id": 1,
      "userId": 1,
      "name": "FEDIUM",
      "description": "Туруктуу өнүгүүгө бирге барабыз"
    }
  ],
  "posts": [
    {
      "id": 1,
      "blogId": 1,
      "userId": 1,
      "title": "21 вдохновляющая история ребят из Баткена, которые добились высот в Google, Microsoft, IBM и не только",
      "subTitle": "Эти талантливые и успешные молодые ребята и девушки прославляют свою малую родину на весь мир. Все они выросли в живописных городах и селах, любимых солнцем и вечерней прохладой снежных гор.",
      "contentMarkup": "<p><i> Сегодня дети этого хлебосольного края покоряют мировые компании, создают свои стартапы и на своем личном примере доказывают, никакие преграды не остановят целеустремленного человека. Limon.KG отобрал для своих читателей 20 вдохновляющих историй одаренных кыргызстанцев из Баткена, которые добились высот в Кремниевой долине, Google, Microsoft, IBM и не только.</i></p><h4>1. Максим Степаненко, соучредитель и технический директор Primer</h4><p>Уроженец г. Айдаркен Баткенской области в 2019 году в Сан-Франциско, Кремниевая долина, запустил образовательный проект Primer. В школьные годы увлекался физикой и даже хотел продолжить учебу в этом направлении. Участвовал в международных олимпиадах, что в дальнейшем помогло ему поступить в Массачусетский технологический институт (MIT), который занимает лидирующие позиции в престижных рейтингах университетов мира.</p><p>Максим работал в Google, MIT Media Lab, Locu. И долгое время был ведущим программистом в Coinbase – одной из крупнейших компаний, работающих с биткоинами. Подробнее о талантливом парне читайте здесь</p><h4>2. Алибек Таалайбек уулу, Software engineer в Meta (Facebook)</h4><p>В 2021 году программист Алибек Таалайбек из г. Кызыл-Кия уулу получил оффер сразу от двух IT-гигантов: Amazon и Meta (Facebook). Он выбрал Meta и сегодня работает в лондонском офисе IT-компании на позиции Software engineer. В послужном списке успешного программиста есть такие компании, как американский Nielsen и корейский стартап Skelter Labs, основанный бывшим директором Goоgle в Корее. Раннее интервью Алибека для Limon.KG читайте здесь. </p><h4>3. Зубайдулло Нийматулло, Software Engineer в Booking.com</h4><p>Программист из г. Кызыл-Кия Зубайдулло Нийматулло уулу получил оффер от IT-гиганта Booking.com и начал работать в Амстердамском офисе компании в Нидерландах в 2021 году. Ранее работал в телекоммуникационной компании 1rstWAP в Дубае, затем устроился в одну из крупнейших IТ-компаний в ОАЭ Group 42, где был старшим программистом.</p><p>Интервью Зубайдулло читайте здесь. </p><h4>4. Арыстан Асанов, DevOps Engineer в PerkSpot</h4><p>Арыстан родился в с. Боз-Адыр, окончил среднюю школу в Оше. Главным человеком, который поддерживал его, была мама, которая привила ему большую любовь к образованию. С 2018 по 2021 году программист работал в компании Leo Burnett, создавал ПО для компании Marlboro. Leo Burnett – это американское глобальное рекламное агентство, которое сотрудничает с компаниями-гигантами, например, Google, Coca-Cola, Bank of America, Dunkin Donuts и страховыми компаниями. С августа 2021 года Асанов работает в стартапе PerkSpot.</p><p>Интервью Арыстана найдете здесь. </p><h4>5. Гульзат Каримова, Software Engineer в Microsoft Leap Apprenticeship Program</h4><p>Девушка из с. Андарак была инженером-программистом в программе профессионального обучения Microsoft Leap с марта по июнь 2021 года. Ранее Гульзат работала в компании Terawe Corporation, которая сотрудничает по контракту с Microsoft. Кстати, девушка всегда интересовалась гуманитарными науками и даже выбрала рекламное дело. Однако после замужества Каримова уехала в США, где решила стать программистом и прошла 6-месячные курсы. Подробнее историю Гульзат вы узнаете здесь.<br /></p><h4>6. Мирланбек Балтабаев, топ-менеджер в HSBC</h4><p>Мирлан, родом из г. Сулюкта, сумел стать топ-менеджером в крупнейшем банке мира HSBC в Малайзии. HSBC является одним из крупнейших финансовых конгломератов в мире, также крупнейшим банком Великобритании по размеру активов и рыночной капитализации. Как из ассистента менеджера Мирлан вырос до менеджера по развитию продукта (Product Development Manager, corporate banking), узнаете в интервью. </p><h4>7. Акжол Абдухалиев, Group Engineering Manager в Microsoft</h4><p>Акжол родом из города Исфаны в Баткенской области, с детства увлекается компьютерными технологиями, что и определило будущее юноши. Он самостоятельно отыскал гимназию в столице и уговорил родителей перевести его туда. Позже он окончил лучший технический вуз Турции - прославленный METU. Как, поработав в Google 5 лет, Акжол вернулся в Microsoft, где начиналась его карьера, читайте здесь. </p><h4>8. Сайрагуль Абдухалиева, Software Development Engineer at Amazon</h4><p>Сайрагуль – инженер-программист в крупной компании Amazon с сентября 2018 года. Она ответственна за голосового ассистента Алекса. Команда, в которой работает наша соотечественница, обеспечивает работу с новыми прототипами устройств. Путь в гигантскую корпорацию начался с университета, где она получила знания по компьютерной инженерии. Она получила степень магистратуры в Турции и с мужем, Акжолом Абдухалиевым, переехала в Штаты. Об обучении кодирования и работе в Амазон, она рассказала в интервью Limon.KG.</p>",
      "isLargePreview": true,
      "imgDescriptor": "1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 2,
      "blogId": 1,
      "userId": 1,
      "title": "Write your own code transform for fun and profit",
      "subTitle": "How to write your own code macro with babel-plugin-macros 🎣",
      "contentMarkup": "<p>If you haven’t heard, <a href=\"https://github.com/kentcdodds/babel-plugin-macros\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-plugin-macros</strike></a> \"enables zero-config, importable babel plugins.\" A few months ago, I published a blog post about it on the official babel blog: <a href=\"https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros\" target=\"_blank\" rel=\"noopener noreferrer\">\"Zero-config code transformation with babel-plugin-macros\"</a>.<br></p><p>Since then, there have been a few exciting developments:<br></p><ol><li><b>You can use it with a create-react-app application</b> (v2 beta) because it’s now included by default in the beta version of <a href=\"https://www.npmjs.com/package/babel-preset-react-app\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-preset-react-app</strike></a> (which is what create-react-app v2 beta is using!)<br></li><li>It was added as an optional transform to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a> by <a href=\"https://twitter.com/FWeinb\" target=\"_blank\" rel=\"noopener noreferrer\">@FWeinb</a></li></ol><p>Up until now, only early adopters have tried to write a macro, though there are a fair amount of people using the growing list of <a href=\"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/macros.md\" target=\"_blank\" rel=\"noopener noreferrer\">existing macros</a>. There are tons of awesome things you can do with <strike>babel-plugin-macros</strike>, and I want to dedicate this newsletter to showing you how to get started playing around with writing your own.</p><p>Let’s start off with a contrived macro that can split a string of text and replace every space with <strike>🐶</strike>. We'll call it <strike>gemmafy</strike> because my dog's name is \"Gemma.\" Woof!<br></p><ol><li>Go to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a><br></li><li>Make sure the language is set to <strike>JavaScript</strike><br></li><li>Make sure the parser is set to <strike>babylon7</strike><br></li><li>Enable the transform and set it to <strike>babel-macros</strike> (or <strike>babel-plugin-macros</strike> as soon as this is merged)<br></li></ol><p>Then copy/paste this in the source (top left) code panel:<br></p><pre>import gemmafy from 'gemmafy.macro'\n<br>console.log(gemmafy('hello world'))</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(gemmafyMacro)\n<br>function gemmafyMacro({ references, state, babel }) {<br>  references.default.forEach(referencePath =&gt; {<br>    const [firstArgumentPath] = referencePath.parentPath.get('arguments')<br>    const stringValue = firstArgumentPath.node.value<br>    const gemmafied = stringValue.split(' ').join(' 🐶 ')<br>    const gemmafyFunctionCallPath = firstArgumentPath.parentPath<br>    const gemmafiedStringLiteralNode = babel.types.stringLiteral(gemmafied)<br>    gemmafyFunctionCallPath.replaceWith(gemmafiedStringLiteralNode)<br>  })<br>}</pre><blockquote>Alternatively, you can <a href=\"https://astexplorer.net/#/gist/b93bac9c0cdeddd6a1888ad7e82f4cbe/e84e9536951bd0d6fec76b9b50e5f6b01539a4c5\" target=\"_blank\" rel=\"noopener noreferrer\">open this</a></blockquote><p>TADA 🎉! You’ve written your (probably) very first babel plugin via a macro!</p><p>Here’s the output that you should be seeing (in the bottom right panel):</p><pre>console.log(\"hello 🐶 world\")</pre><p>You’ll notice that <strike>babel-plugin-macros</strike> will take care of removing the import at the top of the file for you, and our macro replaced the <strike>gemmafy</strike> call with the string.</p><p>So here’s your challenge. Try to add this:<br></p><pre>console.log(gemmafy('hello world', 'world goodbye'))</pre><p>Right now that’ll transpile to:</p><pre>console.log(\"hello 🐶 world\")</pre><p>Your job is to make it do this instead:</p><pre>console.log(\"hello 🐶 world\", \"goodbye 🐶 world\")</pre><p>From there, you can play around with it and do a lot of fun things!</p><p>If you want to see more of the capabilities, then copy this in the source (top left):</p><pre>import myMacro, { JSXMacro } from 'AnyNameThatEndsIn.macro';<br>// (note: in reality, the AnyNameThatEndsIn.macro should be the name of your package<br>// for example: `codegen.macro`)<br>const functionCall = myMacro('Awesome');<br>const jsx = &lt;JSXMacro cool=\"right!?\"&gt;Hi!&lt;/JSXMacro&gt;;<br>const templateLiteral = myMacro`hi ${'there'}`;<br>literallyAnythingWorks(myMacro);</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(myMacro);<br>function myMacro({ references, state, babel }) {<br>  // `state` is the second argument you're passed to a visitor in a<br>  // normal babel plugin. `babel` is the `@babel/core` module.<br>  // do whatever you like to the AST paths you find in `references`.<br>  // open up the console to see what's logged and start playing around!<br>// references.default refers to the default import (`myMacro` above)<br>  // references.JSXMacro refers to the named import of `JSXMacro`<br>  const { JSXMacro = [], default: defaultImport = [] } = references;<br>defaultImport.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"TaggedTemplateExpression\") {<br>      console.log(\"template literal contents\", referencePath.parentPath.get(\"quasi\"));<br>    } else if (referencePath.parentPath.type === \"CallExpression\") {<br>      if (referencePath === referencePath.parentPath.get(\"callee\")) {<br>        console.log(<br>          \"function call arguments (as callee)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      } else if (referencePath.parentPath.get(\"arguments\").includes(referencePath)) {<br>        console.log(<br>          \"function call arguments (as argument)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      }<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>JSXMacro.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"JSXOpeningElement\") {<br>      console.log(\"jsx props\", {<br>        attributes: referencePath.parentPath.get(\"attributes\"),<br>        children: referencePath.parentPath.parentPath.get(\"children\")<br>      });<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>}</pre><p>Next, open up your developer console and check out the console logs. Have fun with that!</p><blockquote>Alternatively, you can just <a href=\"https://astexplorer.net/#/gist/bee085792657d68468353b868a34a2a6/97e09889c85de1f839717a8b351ad4ec1376501a\" target=\"_blank\" rel=\"noopener noreferrer\">go here</a></blockquote><h3>Conclusion</h3><p>I think there are a LOT of really cool places we can go with this technology. I didn’t spend any time in this newsletter talking about the why behind macros or giving you ideas. I’ll link to some resources for ideas below. The basic idea is if there’s a way that you can pre-compile some of your operations, then you can improve runtime performance/bundle size of your application. In addition, this allows you to do some things at build time when you have access to the file system. The possibilities are really endless and we’re just getting started! Enjoy!</p>",
      "isLargePreview": false,
      "imgDescriptor": "1*mJEOJUxW51Vh-Y7cihnS0w.jpeg",
      "date": "Jun 4",
      "readTimeEstimate": "5 min"
    },
    {
      "id": 3,
      "blogId": 1,
      "userId": 1,
      "title": "How I learn an Open Source Codebase",
      "subTitle": "What I do to learn and understand an open source project to which I want to contribute.",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">my newsletter</a>. I publish each email two weeks after it’s sent. Subscribe to get more content like this earlier right in your inbox! 💌</strong></p>\n  <p>Participating in open source has been awesome for me. It has made me and the stuff I make better. A common question that I get from folks is how to go about learning an open source codebase and understand other’s code.<br></p><p>In my blog post <a href=\"https://medium.com/@kentcdodds/open-source-stamina-dafd063f9932\" target=\"_blank\" rel=\"noopener noreferrer\">“Open Source Stamina”</a>, I make an important observation:</p><blockquote><b>You contribute best to something you use regularly.</b></blockquote>\n\n  <p>So while it can be a lot of fun to just jump into any open source project and help out. Sustainable contributions are best found in projects that you use on a regular basis. You have a better understanding of the use cases of the code which will help you understand the code better.</p><h3>Some steps</h3>\n  <p>Here’s a sequence of events I go through when I’m trying to learn or contribute to an open source project:</p><h4>Contributing Guidelines</h4><p>Look at the contributing guidelines first! This can be found in the <strike>README.md</strike> or a <strike>CONTRIBUTING.md</strike> file in the project. If it doesn’t exist, then file an issue and ask the maintainer to either make one or give you an idea of what they expect out of contributions.</p><h4>Project setup</h4><p>When you set up the project on your computer, make sure that you first install the dependencies and that the tests pass (if there are any). For JavaScript projects, you can mostly do:</p><ol><li>clone repo<br></li><li><strike>npm install</strike><br></li><li><strike>npm test</strike><br></li></ol><p>If all that works then you’re ready to go. The last thing you want to do is clone a repo with failing tests, make your change, and think that your change is the reason the tests are failing! This has happened to me :-(</p><h4>Follow the code</h4><p>Next, I try to follow the code in my head starting at the entry point where I’m interested in (like a function call, or a CLI with a certain argument). This can be intimidating for bigger projects, but it’s not as bad as you might think.</p><p>In my blogpost <a href=\"https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4\" target=\"_blank\" rel=\"noopener noreferrer\">“What open source project should I contribute to?”</a> I talk a little bit about how to find where the code is for a specific API.</p><h4>Break things</h4><p>Reading and running the tests is also useful. Breaking things can also be a helpful way to learn a codebase.</p><h4>Log and step through</h4><p>It’s a tried and true debugging mechanism: <strike>console.log</strike> is a great way to learn a codebase. 👍 Even better if you can run it in the browser DevTools that’s also great. <a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\" target=\"_blank\" rel=\"noopener noreferrer\">Read more about NodeJS debugging in Chrome DevTools</a>.</p><p>One other thing you might try is running the project’s code in the context of your application. I talk about this a fair amount in my blog post from a few weeks ago <a href=\"https://blog.kentcdodds.com/spelunking-in-node-modules-bf165af19968\" target=\"_blank\" rel=\"noopener noreferrer\">“Spelunking in node_modules 👷”</a>.</p><h3>Conclusion</h3><p>Something else that I’ve found helpful is to ask someone on the project to walk me through some part of the code. I try to make it worth their time by offering to record our conversation and make it publicly available. This is appealing to maintainers because having material out there for new contributors to watch is very helpful. Here are some examples:</p><ul><li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Why, What, and How of React Fiber with Dan Abramov and Andrew Clark</a><br></li><li><a href=\"https://www.youtube.com/watch?v=dRo_egw7tBc&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a><br></li><li><a href=\"https://www.youtube.com/watch?v=i31VtyJSM-I&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript &amp; React Testing with Jest</a><br></li><li><a href=\"https://www.youtube.com/watch?v=wUpPsEcGsg8&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Contributing to ReactJS</a><br></li></ul><p>I hope this is helpful! Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*NbePWo0hJrYA4mHeQBHmDw.jpeg",
      "date": "May 14",
      "readTimeEstimate": "4 min"
    },
    {
      "id": 4,
      "blogId": 1,
      "userId": 1,
      "title": "Кыргызстандык Кемел Оксфорд университети менен кызматташып, Amazon`до сатылуучу китеп чыгарды",
      "subTitle": "",
      "contentMarkup": "<p><strike>Гарвард, Экзетер, Лондон экономика мектеби – Кемел Кыргызстандагы эң жаш илимдин докторлорунун бири. Limon.KG'ге берген бул маегинде ал Бишкектеги кадимки мектептен дүйнөлүк алдыңкы жогорку окуу жайларына чейин басып өткөн жолу тууралуу айтып берди. Бул билимдер өз жемишин бере баштап, Кемел Оксфорд университети менен кызматташып, жакында Amazon компаниясына сатыла турган китеп чыгаруунун алдында турат. Бул макаладан анын ою боюнча “ийкемдүүлүк жөндөмдөрү” эмне үчүн маанилүү, жеке финансы жана инвестициялоонун негиздери эмне үчүн мектептерде окутулушу керек жана ал эмне үчүн Кыргызстанда иштөөнү тандай турганын биле аласыз.</strike><br /></p><p></p><ul><li><b>Саламатсызбы, Кемел. Балалыгыңыз кандай өткөнү тууралуу билсек дегенбиз?</b></li></ul><p></p><p>Мага балалыгым кадимкидей эле өткөндөй сезилет. Кадимки короодо ойноп, катардагы мектептердин биринде окудум. Мектепти аяктагандан кийин жөнөкөй эле институтка окууга тапшырып, катардагы юристтердин бири болом, кадимки жашоодо жашайм деп ойлогонмун.</p><p>Балким, бир окуя орун албаганда баары ошондой нукта уланмак. Анда 11-класста окуйт элем, англис тили сабагына келсем, мугалим бардык мыкты окуучуларды “Келечектеги лидердер” (FLEX) сынагына катышуу үчүн сабактан бошотуп жибергенин айтты. Баш байге – америкалык мектептердин биринде бир жыл бою акысыз билим алуу эле. А мага болсо класста калып, башка сабактарга жакшылап даярдануум керек экенин, “баары бир менден натыйжа чыкпасын” айтты.</p><p>Бул сөз абдан кыжырымды келтирип, жарым сааттан кийин тесттин биринчи баскычына катышууга кезекте тургандардын катарына кошулдум. Жыйынтыгында тилди анча жакшы билбесем да, мектебибиз алдыңкы мектептердин катарына кирбесе да, биздин мектептен жалгыз мен өтүп, Америкага кетүү мүмкүнчүлүгүн алдым.</p><p>Мындан мен өзүмө эң биринчи маанилүү сабакты ала алдым. Эң негизгиси – бүтүн дүйнө каршы болсо да, өзүңө, өз күчүңө ишенишиң керек экен.</p><p>Бул окуядан алган экинчи сабак – дүйнөлүк алкакта ойлонуу керек. АКШга болгон сапар менин көзүмдү ачты. Мен бүткүл дүйнө биздин алаканыбызда экенин түшүндүм. Мурда Гарвард университетин бир гана телевизордон көрөм деп ойлосом, АКШга келгенден кийин мүмкүн эмес деген нерсе жок экенин аңдап жеттим.</p><p>Бардык нерсени окуп-өздөштүрүп, баарына жетсе болот. Мен өзүмө, өз күчүмө ишене баштадым. Эми дүйнөлүк алдыңкы окуу жайларга тапшыруудан коркпой калдым. Ошентип Лондон экономикалык мектебинде окуп, Экзетера университетинде доктордукту жактадым. Ошондой эле Гарвардда атайын курстарды өттүм.</p><ul><li><b>Лондон экономикалык мектепбинде окуу кандай эле?</b></li></ul><p>Ачыгын айтканда башында бир аз корктум. Сабакта отуруп, 20-30 жашында көп нерсеге жете алган крсташтарыңды көрүп ойлоносуң: “Бул жерге өтүп калганым өзү эле менин ийгилигим чыгар” же “мен аларга окшош акылдуу же ийгиликтүү эмес экенимди билишсе эмне болот?”. Бирок иш жүзүндө ар бир адам уникалдуу, ар биринин өзүнүн артыкчылыктары жана жетишкендиктери бар, балким сиз өзүңүзгө мындай ракурстан карап көрө элексиз.</p><p>Моюнга алышым керек, биринчи айлары менин билимим жетишсиз сезилгендиктен, китептерге сүңгүп кеттим. Курсташтарымдан бир топ эле артта калып калганымды сезчү элем. Күчтүүлөрдүн атмосферасы сага профессионалдык да, жеке адам катары да өсүүгө жардам берет. Сен да алардай, алардан да мыкты болууга аракет кыласың. Ошол эле Гарвард же Стенфорд университетинин студенттери таптакыр сабак өтүлбөсө да бары бир ийгиликтүү болушат. Анткени бул окуу жайлар башынан эле эң мыкты, күчтүү студенттерди тандап алып, аларды бир жерде аралаштырып, бири-бири менен атаандаштык чөйрөнү түзүп коюшат.</p><ul><li><b>Ушундай баа жеткис тажрыйба ала алганыңыз үчүн кубанычтабыз. Экзетера университетинде доктордукту жактоо чечимиңиз эмне менен байланыштуу эле?</b></li></ul><p>Заманбап экономиканын өнүгүшүнүн негизги факторлору билим жана адамдык капитал экенине ишенем. Докторантура жаңы билимдерди түзүү жана жаңы жөндөмдөрдү өнүктүрүү эмеспи. Анан калса мен сабак берүүдөн ырахат алам. Студенттерим татаал нерселерди оңой жана жөнөкөй тил менен жеткире аласыз деп көп айтышат. Мындай сөздөр мотивация берип, шыктандырат.</p><p>Жылына бир ирет Нарындагы Борбордук Азия Университетинде (БАУ, УЦА) сабак берүү үчүн барып келем. Ал жакта мен сабак берген студенттер саясат таануу же экономиканы окуган студенттер эмес, менин сабагым аларга эмне үчүн керек экенин түшүнө албаган программист жана журналисттер. Бирок биринчи эле сабактан кийин кызыга башташат.</p><p>Анткени менин курсум сынчыл (критикалык) ой жүгүртүү, табармандык (креативдүүлүк), ишендире алуу жана уга билүү, адаптация сыяктуу көндүмдөрдү камтыган “ийкемдүүлүк жөндөмдөрү” (soft skills) тууралуу. Азыркы кырдаал ушундай, дүйнө жүзүндөгү көпчүлүк билим берүү системасы келечектеги эмгек рыногун алдын ала биле албайт.</p><p>Ошол эле LinkedIn өз платформасында жакын арада төмөнкү кесип ээлери суроо-талапка ээ болот деп жарыялаган эле: ири маалыматтарды анализдөөчү адистер, жасалма интеллект боюнча адистер, интернет-коопсуздук боюнча инженерлер, каатчылык (кризис) боюнча консультант жана онлайн-окутуучулар. Б.а. дээрлик 5 жыл мурда жок болгон кесиптер.</p><p>Демек, университеттер азырынча жарала элек көйгөйлөрдү чечүү үчүн, али түзүлүп чыга элек технологияларды колдонуу менен, азыр жарала элек кесиптердин адистерин даярдашы керек. Эгер дүйнөнүн алдыңкы окуу жайлары заманбап эмгек рыногунун талаптарын алдын ала байкап, ыкчам реакция жасай алса, көпчүлүк ЖОЖдордун бул нерсеге кудурети жетпейт. Ошондуктан даярдык жок болгон кокустуктар орун алган күндө да эмгек рыногунда талапка ээ адис болууга керектүү билим жана жөндөмдөрдү өздөштүрүү керек. Дал ушул учурда “ийкемдүүлүк жөндөмдөр” жардамга келет.</p>",
      "isLargePreview": true,
      "imgDescriptor": "1*SI4Nd9m-LunZXicI_mE4gw.png",
      "date": "Jun 18",
      "readTimeEstimate": "4 min"
    },
    {
      "id": 5,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it’s good, why it’s bad, and how to avoid common problems with it.",
      "contentMarkup": "<p><b>NOTE: This is a cross-post from my <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">newsletter</a>. I publish each email two weeks after it’s sent. Subscribe to get more content like this earlier right in your inbox! 💌</b></p><p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as “threading”), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</pre><p>Let’s refactor this into two components now:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        The button is {on ? 'on' : 'off'}<br>      &lt;/div&gt;<br>      &lt;button onClick={onToggle}&gt;<br>        Toggle<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre><p>Simple enough, the <strike>Switch</strike> needs a reference to the <strike>toggle</strike> and <strike>on</strike> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;SwitchMessage on={on} /&gt;<br>      &lt;SwitchButton onToggle={onToggle} /&gt;<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchMessage({on}) {<br>  return (<br>    &lt;div&gt;<br>      The button is {on ? 'on' : 'off'}<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchButton({onToggle}) {<br>  return (<br>    &lt;button onClick={onToggle}&gt;<br>      Toggle<br>    &lt;/button&gt;<br>  )<br>}</pre><p>This is prop drilling. To get the <strike>on</strike> state and <strike>toggle</strike> handler to the right places, we have to drill (or thread) props through the <strike>Switch</strike> component. The <strike>Switch</strike> component itself doesn't actually need those values to function, but we have to accept and forward those props because its children need them.</p><h3>Why is prop drilling good?</h3><p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <strike>$scope</strike> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <b>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</b></p><p>One reason we prefer ESModules over global variables is because it allows us to be more explicit about where our values are used, making it much easier to track values and eases the process determining what impact your changes will have on the rest of the application.</p><p>Prop drilling at its most basic level is simply explicitly passing values throughout the view of your application. This is great because if you were coming to the <strike>Toggle</strike> above and decided you want to refactor the <strike>on</strike> state to be an enum, you'd easily be able to track all places it's used by following the code statically (without having to run it) and make that update. The key here is explicitness over implicitness.</p><h3>What problems can prop drilling cause?</h3><p>In our contrived example above, there’s absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It’s not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p><ul><li>Refactor the shape of some data (ie: <strike>{user: {name: 'Joe West'}}</strike> -&gt; <strike>{user: {firstName: 'Joe', lastName: 'West'}}</strike>).</li><li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they’re no longer needed.</li><li>Under-forwarding props + abusing <strike>defaultProps</strike> so you're not made aware of missing props (also due to (re)moving a component).</li><li>Renaming props halfway through (ie <strike>&lt;Toggle on={this.state.on} /&gt;</strike> renders <strike>&lt;Switch toggleIsOn={on} /&gt;</strike>) making keeping track of that in your brain difficult.</li></ul><p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p><h3>How can we avoid problems with prop drilling?</h3><p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!<br></p><blockquote>Fun fact, there’s nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you’d have one giant render method… I am not advocating this though… Just something to think about :)</blockquote><p>Another thing you can can do to mitigate the effects of prop-drilling is avoid using defaultProps for anything that's a required prop. Using a defaultProp for something that's actually required for the component to function properly is just hiding important errors and making things fail silently. So only use defaultProps for things that are not required.<br></p><p>Keep state as close to where it’s relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: <a href=\"https://blog.kentcdodds.com/application-state-management-66de608ccb24\" target=\"_blank\" rel=\"noopener noreferrer\">Application State Management</a>.<br></p><p>Use React’s new Context API for things that are truly necessary deep in the react tree. They don’t have to be things you need everywhere in the application (you can render a provider anywhere in the app). This can really help avoid some issues with prop drilling. It’s been noted that context is kinda taking us back to the days of global variables. The difference is that because of the way the API was designed, you can still statically find the source of the context as well as any consumers with relative ease.<br></p><h3>Conclusion</h3><p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 6,
      "blogId": 1,
      "userId": 1,
      "title": "Write your own code transform for fun and profit",
      "subTitle": "How to write your own code macro with babel-plugin-macros 🎣",
      "contentMarkup": "<p>If you haven’t heard, <a href=\"https://github.com/kentcdodds/babel-plugin-macros\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-plugin-macros</strike></a> \"enables zero-config, importable babel plugins.\" A few months ago, I published a blog post about it on the official babel blog: <a href=\"https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros\" target=\"_blank\" rel=\"noopener noreferrer\">\"Zero-config code transformation with babel-plugin-macros\"</a>.<br></p><p>Since then, there have been a few exciting developments:<br></p><ol><li><b>You can use it with a create-react-app application</b> (v2 beta) because it’s now included by default in the beta version of <a href=\"https://www.npmjs.com/package/babel-preset-react-app\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-preset-react-app</strike></a> (which is what create-react-app v2 beta is using!)<br></li><li>It was added as an optional transform to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a> by <a href=\"https://twitter.com/FWeinb\" target=\"_blank\" rel=\"noopener noreferrer\">@FWeinb</a></li></ol><p>Up until now, only early adopters have tried to write a macro, though there are a fair amount of people using the growing list of <a href=\"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/macros.md\" target=\"_blank\" rel=\"noopener noreferrer\">existing macros</a>. There are tons of awesome things you can do with <strike>babel-plugin-macros</strike>, and I want to dedicate this newsletter to showing you how to get started playing around with writing your own.</p><p>Let’s start off with a contrived macro that can split a string of text and replace every space with <strike>🐶</strike>. We'll call it <strike>gemmafy</strike> because my dog's name is \"Gemma.\" Woof!<br></p><ol><li>Go to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a><br></li><li>Make sure the language is set to <strike>JavaScript</strike><br></li><li>Make sure the parser is set to <strike>babylon7</strike><br></li><li>Enable the transform and set it to <strike>babel-macros</strike> (or <strike>babel-plugin-macros</strike> as soon as this is merged)<br></li></ol><p>Then copy/paste this in the source (top left) code panel:<br></p><pre>import gemmafy from 'gemmafy.macro'\n<br>console.log(gemmafy('hello world'))</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(gemmafyMacro)\n<br>function gemmafyMacro({ references, state, babel }) {<br>  references.default.forEach(referencePath =&gt; {<br>    const [firstArgumentPath] = referencePath.parentPath.get('arguments')<br>    const stringValue = firstArgumentPath.node.value<br>    const gemmafied = stringValue.split(' ').join(' 🐶 ')<br>    const gemmafyFunctionCallPath = firstArgumentPath.parentPath<br>    const gemmafiedStringLiteralNode = babel.types.stringLiteral(gemmafied)<br>    gemmafyFunctionCallPath.replaceWith(gemmafiedStringLiteralNode)<br>  })<br>}</pre><blockquote>Alternatively, you can <a href=\"https://astexplorer.net/#/gist/b93bac9c0cdeddd6a1888ad7e82f4cbe/e84e9536951bd0d6fec76b9b50e5f6b01539a4c5\" target=\"_blank\" rel=\"noopener noreferrer\">open this</a></blockquote><p>TADA 🎉! You’ve written your (probably) very first babel plugin via a macro!</p><p>Here’s the output that you should be seeing (in the bottom right panel):</p><pre>console.log(\"hello 🐶 world\")</pre><p>You’ll notice that <strike>babel-plugin-macros</strike> will take care of removing the import at the top of the file for you, and our macro replaced the <strike>gemmafy</strike> call with the string.</p><p>So here’s your challenge. Try to add this:<br></p><pre>console.log(gemmafy('hello world', 'world goodbye'))</pre><p>Right now that’ll transpile to:</p><pre>console.log(\"hello 🐶 world\")</pre><p>Your job is to make it do this instead:</p><pre>console.log(\"hello 🐶 world\", \"goodbye 🐶 world\")</pre><p>From there, you can play around with it and do a lot of fun things!</p><p>If you want to see more of the capabilities, then copy this in the source (top left):</p><pre>import myMacro, { JSXMacro } from 'AnyNameThatEndsIn.macro';<br>// (note: in reality, the AnyNameThatEndsIn.macro should be the name of your package<br>// for example: `codegen.macro`)<br>const functionCall = myMacro('Awesome');<br>const jsx = &lt;JSXMacro cool=\"right!?\"&gt;Hi!&lt;/JSXMacro&gt;;<br>const templateLiteral = myMacro`hi ${'there'}`;<br>literallyAnythingWorks(myMacro);</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(myMacro);<br>function myMacro({ references, state, babel }) {<br>  // `state` is the second argument you're passed to a visitor in a<br>  // normal babel plugin. `babel` is the `@babel/core` module.<br>  // do whatever you like to the AST paths you find in `references`.<br>  // open up the console to see what's logged and start playing around!<br>// references.default refers to the default import (`myMacro` above)<br>  // references.JSXMacro refers to the named import of `JSXMacro`<br>  const { JSXMacro = [], default: defaultImport = [] } = references;<br>defaultImport.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"TaggedTemplateExpression\") {<br>      console.log(\"template literal contents\", referencePath.parentPath.get(\"quasi\"));<br>    } else if (referencePath.parentPath.type === \"CallExpression\") {<br>      if (referencePath === referencePath.parentPath.get(\"callee\")) {<br>        console.log(<br>          \"function call arguments (as callee)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      } else if (referencePath.parentPath.get(\"arguments\").includes(referencePath)) {<br>        console.log(<br>          \"function call arguments (as argument)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      }<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>JSXMacro.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"JSXOpeningElement\") {<br>      console.log(\"jsx props\", {<br>        attributes: referencePath.parentPath.get(\"attributes\"),<br>        children: referencePath.parentPath.parentPath.get(\"children\")<br>      });<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>}</pre><p>Next, open up your developer console and check out the console logs. Have fun with that!</p><blockquote>Alternatively, you can just <a href=\"https://astexplorer.net/#/gist/bee085792657d68468353b868a34a2a6/97e09889c85de1f839717a8b351ad4ec1376501a\" target=\"_blank\" rel=\"noopener noreferrer\">go here</a></blockquote><h3>Conclusion</h3><p>I think there are a LOT of really cool places we can go with this technology. I didn’t spend any time in this newsletter talking about the why behind macros or giving you ideas. I’ll link to some resources for ideas below. The basic idea is if there’s a way that you can pre-compile some of your operations, then you can improve runtime performance/bundle size of your application. In addition, this allows you to do some things at build time when you have access to the file system. The possibilities are really endless and we’re just getting started! Enjoy!</p>",
      "isLargePreview": false,
      "imgDescriptor": "1*mJEOJUxW51Vh-Y7cihnS0w.jpeg",
      "date": "Jun 4",
      "readTimeEstimate": "5 min"
    },
    {
      "id": 7,
      "blogId": 1,
      "userId": 1,
      "title": "How I learn an Open Source Codebase",
      "subTitle": "What I do to learn and understand an open source project to which I want to contribute.",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">my newsletter</a>. I publish each email two weeks after it’s sent. Subscribe to get more content like this earlier right in your inbox! 💌</strong></p>\n  <p>Participating in open source has been awesome for me. It has made me and the stuff I make better. A common question that I get from folks is how to go about learning an open source codebase and understand other’s code.<br></p><p>In my blog post <a href=\"https://medium.com/@kentcdodds/open-source-stamina-dafd063f9932\" target=\"_blank\" rel=\"noopener noreferrer\">“Open Source Stamina”</a>, I make an important observation:</p><blockquote><b>You contribute best to something you use regularly.</b></blockquote>\n\n  <p>So while it can be a lot of fun to just jump into any open source project and help out. Sustainable contributions are best found in projects that you use on a regular basis. You have a better understanding of the use cases of the code which will help you understand the code better.</p><h3>Some steps</h3>\n  <p>Here’s a sequence of events I go through when I’m trying to learn or contribute to an open source project:</p><h4>Contributing Guidelines</h4><p>Look at the contributing guidelines first! This can be found in the <strike>README.md</strike> or a <strike>CONTRIBUTING.md</strike> file in the project. If it doesn’t exist, then file an issue and ask the maintainer to either make one or give you an idea of what they expect out of contributions.</p><h4>Project setup</h4><p>When you set up the project on your computer, make sure that you first install the dependencies and that the tests pass (if there are any). For JavaScript projects, you can mostly do:</p><ol><li>clone repo<br></li><li><strike>npm install</strike><br></li><li><strike>npm test</strike><br></li></ol><p>If all that works then you’re ready to go. The last thing you want to do is clone a repo with failing tests, make your change, and think that your change is the reason the tests are failing! This has happened to me :-(</p><h4>Follow the code</h4><p>Next, I try to follow the code in my head starting at the entry point where I’m interested in (like a function call, or a CLI with a certain argument). This can be intimidating for bigger projects, but it’s not as bad as you might think.</p><p>In my blogpost <a href=\"https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4\" target=\"_blank\" rel=\"noopener noreferrer\">“What open source project should I contribute to?”</a> I talk a little bit about how to find where the code is for a specific API.</p><h4>Break things</h4><p>Reading and running the tests is also useful. Breaking things can also be a helpful way to learn a codebase.</p><h4>Log and step through</h4><p>It’s a tried and true debugging mechanism: <strike>console.log</strike> is a great way to learn a codebase. 👍 Even better if you can run it in the browser DevTools that’s also great. <a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\" target=\"_blank\" rel=\"noopener noreferrer\">Read more about NodeJS debugging in Chrome DevTools</a>.</p><p>One other thing you might try is running the project’s code in the context of your application. I talk about this a fair amount in my blog post from a few weeks ago <a href=\"https://blog.kentcdodds.com/spelunking-in-node-modules-bf165af19968\" target=\"_blank\" rel=\"noopener noreferrer\">“Spelunking in node_modules 👷”</a>.</p><h3>Conclusion</h3><p>Something else that I’ve found helpful is to ask someone on the project to walk me through some part of the code. I try to make it worth their time by offering to record our conversation and make it publicly available. This is appealing to maintainers because having material out there for new contributors to watch is very helpful. Here are some examples:</p><ul><li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Why, What, and How of React Fiber with Dan Abramov and Andrew Clark</a><br></li><li><a href=\"https://www.youtube.com/watch?v=dRo_egw7tBc&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a><br></li><li><a href=\"https://www.youtube.com/watch?v=i31VtyJSM-I&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript &amp; React Testing with Jest</a><br></li><li><a href=\"https://www.youtube.com/watch?v=wUpPsEcGsg8&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Contributing to ReactJS</a><br></li></ul><p>I hope this is helpful! Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*NbePWo0hJrYA4mHeQBHmDw.jpeg",
      "date": "May 14",
      "readTimeEstimate": "4 min"
    },
    {
      "id": 8,
      "blogId": 1,
      "userId": 1,
      "title": "Prop Drilling",
      "subTitle": "What it is, why it’s good, why it’s bad, and how to avoid common problems with it.",
      "contentMarkup": "<p><b>NOTE: This is a cross-post from my <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">newsletter</a>. I publish each email two weeks after it’s sent. Subscribe to get more content like this earlier right in your inbox! 💌</b></p><p>The goal of this post is to not only help you understand what prop drilling is (some also refer to it as “threading”), but also when it can be a problem and mechanisms you can use to side-step or avoid it.</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          The button is {this.state.on ? 'on' : 'off'}<br>        &lt;/div&gt;<br>        &lt;button onClick={this.toggle}&gt;<br>          Toggle<br>        &lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  }<br>}</pre><p>Let’s refactor this into two components now:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        The button is {on ? 'on' : 'off'}<br>      &lt;/div&gt;<br>      &lt;button onClick={onToggle}&gt;<br>        Toggle<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre><p>Simple enough, the <strike>Switch</strike> needs a reference to the <strike>toggle</strike> and <strike>on</strike> state, so we're sending some props there. Let's refactor it once more to add another layer in our component tree:</p><pre>class Toggle extends React.Component {<br>  state = {on: false}<br>  toggle = () =&gt; this.setState(<br>    ({on}) =&gt; ({on: !on})<br>  )<br>  render() {<br>    return (<br>      &lt;Switch<br>        on={this.state.on}<br>        onToggle={this.toggle}<br>      /&gt;<br>    )<br>  }<br>}<br>function Switch({on, onToggle}) {<br>  return (<br>    &lt;div&gt;<br>      &lt;SwitchMessage on={on} /&gt;<br>      &lt;SwitchButton onToggle={onToggle} /&gt;<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchMessage({on}) {<br>  return (<br>    &lt;div&gt;<br>      The button is {on ? 'on' : 'off'}<br>    &lt;/div&gt;<br>  )<br>}<br>function SwitchButton({onToggle}) {<br>  return (<br>    &lt;button onClick={onToggle}&gt;<br>      Toggle<br>    &lt;/button&gt;<br>  )<br>}</pre><p>This is prop drilling. To get the <strike>on</strike> state and <strike>toggle</strike> handler to the right places, we have to drill (or thread) props through the <strike>Switch</strike> component. The <strike>Switch</strike> component itself doesn't actually need those values to function, but we have to accept and forward those props because its children need them.</p><h3>Why is prop drilling good?</h3><p>Did you ever work in an application that used global variables? What about an AngularJS application that leveraged non-isolate <strike>$scope</strike> inheritance? The reason that the community has largely rejected these methodologies is because it inevitably leads to a very confusing data model for your application. It becomes difficult for anyone to find where data is initialized, where it's updated, and where it's used. <b>Answering the question of \"can I modify/delete this code without breaking anything?\" is difficult to answer in that kind of a world. And that's the question you should be optimizing for as you code.</b></p><p>One reason we prefer ESModules over global variables is because it allows us to be more explicit about where our values are used, making it much easier to track values and eases the process determining what impact your changes will have on the rest of the application.</p><p>Prop drilling at its most basic level is simply explicitly passing values throughout the view of your application. This is great because if you were coming to the <strike>Toggle</strike> above and decided you want to refactor the <strike>on</strike> state to be an enum, you'd easily be able to track all places it's used by following the code statically (without having to run it) and make that update. The key here is explicitness over implicitness.</p><h3>What problems can prop drilling cause?</h3><p>In our contrived example above, there’s absolutely no problem. But as an application grows, you may find yourself drilling through many layers of components. It’s not normally a big deal when you write it out initially, but after that code has been worked in for a few weeks, things start to get unwieldy for a few use cases:</p><ul><li>Refactor the shape of some data (ie: <strike>{user: {name: 'Joe West'}}</strike> -&gt; <strike>{user: {firstName: 'Joe', lastName: 'West'}}</strike>).</li><li>Over-forwarding props (passing more props than is necessary) due to (re)moving a component that required some props but they’re no longer needed.</li><li>Under-forwarding props + abusing <strike>defaultProps</strike> so you're not made aware of missing props (also due to (re)moving a component).</li><li>Renaming props halfway through (ie <strike>&lt;Toggle on={this.state.on} /&gt;</strike> renders <strike>&lt;Switch toggleIsOn={on} /&gt;</strike>) making keeping track of that in your brain difficult.</li></ul><p>There are various other situations where prop drilling can cause some real pain in the process of refactoring especially.</p><h3>How can we avoid problems with prop drilling?</h3><p>One of the things that really aggravates problems with prop drilling is breaking out your render method into multiple components unnecessarily. You'll be surprised how simple a big render method can be when you just inline as much as you can. There's no reason to breaking things out prematurely. Wait until you really need to reuse a block before breaking it out. Then you wont need to pass props anyway!<br></p><blockquote>Fun fact, there’s nothing technically stopping you from writing your entire application as a single React Component. It can manage the state of your whole application and you’d have one giant render method… I am not advocating this though… Just something to think about :)</blockquote><p>Another thing you can can do to mitigate the effects of prop-drilling is avoid using defaultProps for anything that's a required prop. Using a defaultProp for something that's actually required for the component to function properly is just hiding important errors and making things fail silently. So only use defaultProps for things that are not required.<br></p><p>Keep state as close to where it’s relevant as possible. If only one section of your app needs some state, then manage that in the least common parent of those components rather than putting it at the highest level of the app. Learn more about state management from my blog post: <a href=\"https://blog.kentcdodds.com/application-state-management-66de608ccb24\" target=\"_blank\" rel=\"noopener noreferrer\">Application State Management</a>.<br></p><p>Use React’s new Context API for things that are truly necessary deep in the react tree. They don’t have to be things you need everywhere in the application (you can render a provider anywhere in the app). This can really help avoid some issues with prop drilling. It’s been noted that context is kinda taking us back to the days of global variables. The difference is that because of the way the API was designed, you can still statically find the source of the context as well as any consumers with relative ease.<br></p><h3>Conclusion</h3><p>Prop drilling can be a good thing, and it can be a bad thing. Following some good practices as mentioned above, you can use it as a feature to make your application more maintainable. Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*bWg9ZF6pzx0vddYqAnf5FA.jpeg",
      "date": "May 21",
      "readTimeEstimate": "6 min"
    },
    {
      "id": 9,
      "blogId": 1,
      "userId": 1,
      "title": "Write your own code transform for fun and profit",
      "subTitle": "How to write your own code macro with babel-plugin-macros 🎣",
      "contentMarkup": "<p>If you haven’t heard, <a href=\"https://github.com/kentcdodds/babel-plugin-macros\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-plugin-macros</strike></a> \"enables zero-config, importable babel plugins.\" A few months ago, I published a blog post about it on the official babel blog: <a href=\"https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros\" target=\"_blank\" rel=\"noopener noreferrer\">\"Zero-config code transformation with babel-plugin-macros\"</a>.<br></p><p>Since then, there have been a few exciting developments:<br></p><ol><li><b>You can use it with a create-react-app application</b> (v2 beta) because it’s now included by default in the beta version of <a href=\"https://www.npmjs.com/package/babel-preset-react-app\" target=\"_blank\" rel=\"noopener noreferrer\"><strike>babel-preset-react-app</strike></a> (which is what create-react-app v2 beta is using!)<br></li><li>It was added as an optional transform to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a> by <a href=\"https://twitter.com/FWeinb\" target=\"_blank\" rel=\"noopener noreferrer\">@FWeinb</a></li></ol><p>Up until now, only early adopters have tried to write a macro, though there are a fair amount of people using the growing list of <a href=\"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/macros.md\" target=\"_blank\" rel=\"noopener noreferrer\">existing macros</a>. There are tons of awesome things you can do with <strike>babel-plugin-macros</strike>, and I want to dedicate this newsletter to showing you how to get started playing around with writing your own.</p><p>Let’s start off with a contrived macro that can split a string of text and replace every space with <strike>🐶</strike>. We'll call it <strike>gemmafy</strike> because my dog's name is \"Gemma.\" Woof!<br></p><ol><li>Go to <a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener noreferrer\">astexplorer.net</a><br></li><li>Make sure the language is set to <strike>JavaScript</strike><br></li><li>Make sure the parser is set to <strike>babylon7</strike><br></li><li>Enable the transform and set it to <strike>babel-macros</strike> (or <strike>babel-plugin-macros</strike> as soon as this is merged)<br></li></ol><p>Then copy/paste this in the source (top left) code panel:<br></p><pre>import gemmafy from 'gemmafy.macro'\n<br>console.log(gemmafy('hello world'))</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(gemmafyMacro)\n<br>function gemmafyMacro({ references, state, babel }) {<br>  references.default.forEach(referencePath =&gt; {<br>    const [firstArgumentPath] = referencePath.parentPath.get('arguments')<br>    const stringValue = firstArgumentPath.node.value<br>    const gemmafied = stringValue.split(' ').join(' 🐶 ')<br>    const gemmafyFunctionCallPath = firstArgumentPath.parentPath<br>    const gemmafiedStringLiteralNode = babel.types.stringLiteral(gemmafied)<br>    gemmafyFunctionCallPath.replaceWith(gemmafiedStringLiteralNode)<br>  })<br>}</pre><blockquote>Alternatively, you can <a href=\"https://astexplorer.net/#/gist/b93bac9c0cdeddd6a1888ad7e82f4cbe/e84e9536951bd0d6fec76b9b50e5f6b01539a4c5\" target=\"_blank\" rel=\"noopener noreferrer\">open this</a></blockquote><p>TADA 🎉! You’ve written your (probably) very first babel plugin via a macro!</p><p>Here’s the output that you should be seeing (in the bottom right panel):</p><pre>console.log(\"hello 🐶 world\")</pre><p>You’ll notice that <strike>babel-plugin-macros</strike> will take care of removing the import at the top of the file for you, and our macro replaced the <strike>gemmafy</strike> call with the string.</p><p>So here’s your challenge. Try to add this:<br></p><pre>console.log(gemmafy('hello world', 'world goodbye'))</pre><p>Right now that’ll transpile to:</p><pre>console.log(\"hello 🐶 world\")</pre><p>Your job is to make it do this instead:</p><pre>console.log(\"hello 🐶 world\", \"goodbye 🐶 world\")</pre><p>From there, you can play around with it and do a lot of fun things!</p><p>If you want to see more of the capabilities, then copy this in the source (top left):</p><pre>import myMacro, { JSXMacro } from 'AnyNameThatEndsIn.macro';<br>// (note: in reality, the AnyNameThatEndsIn.macro should be the name of your package<br>// for example: `codegen.macro`)<br>const functionCall = myMacro('Awesome');<br>const jsx = &lt;JSXMacro cool=\"right!?\"&gt;Hi!&lt;/JSXMacro&gt;;<br>const templateLiteral = myMacro`hi ${'there'}`;<br>literallyAnythingWorks(myMacro);</pre><p>And copy/paste this in the transform (bottom left) code panel:<br></p><pre>module.exports = createMacro(myMacro);<br>function myMacro({ references, state, babel }) {<br>  // `state` is the second argument you're passed to a visitor in a<br>  // normal babel plugin. `babel` is the `@babel/core` module.<br>  // do whatever you like to the AST paths you find in `references`.<br>  // open up the console to see what's logged and start playing around!<br>// references.default refers to the default import (`myMacro` above)<br>  // references.JSXMacro refers to the named import of `JSXMacro`<br>  const { JSXMacro = [], default: defaultImport = [] } = references;<br>defaultImport.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"TaggedTemplateExpression\") {<br>      console.log(\"template literal contents\", referencePath.parentPath.get(\"quasi\"));<br>    } else if (referencePath.parentPath.type === \"CallExpression\") {<br>      if (referencePath === referencePath.parentPath.get(\"callee\")) {<br>        console.log(<br>          \"function call arguments (as callee)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      } else if (referencePath.parentPath.get(\"arguments\").includes(referencePath)) {<br>        console.log(<br>          \"function call arguments (as argument)\",<br>          referencePath.parentPath.get(\"arguments\")<br>        );<br>      }<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>JSXMacro.forEach(referencePath =&gt; {<br>    if (referencePath.parentPath.type === \"JSXOpeningElement\") {<br>      console.log(\"jsx props\", {<br>        attributes: referencePath.parentPath.get(\"attributes\"),<br>        children: referencePath.parentPath.parentPath.get(\"children\")<br>      });<br>    } else {<br>      // throw a helpful error message or something :)<br>    }<br>  });<br>}</pre><p>Next, open up your developer console and check out the console logs. Have fun with that!</p><blockquote>Alternatively, you can just <a href=\"https://astexplorer.net/#/gist/bee085792657d68468353b868a34a2a6/97e09889c85de1f839717a8b351ad4ec1376501a\" target=\"_blank\" rel=\"noopener noreferrer\">go here</a></blockquote><h3>Conclusion</h3><p>I think there are a LOT of really cool places we can go with this technology. I didn’t spend any time in this newsletter talking about the why behind macros or giving you ideas. I’ll link to some resources for ideas below. The basic idea is if there’s a way that you can pre-compile some of your operations, then you can improve runtime performance/bundle size of your application. In addition, this allows you to do some things at build time when you have access to the file system. The possibilities are really endless and we’re just getting started! Enjoy!</p>",
      "isLargePreview": false,
      "imgDescriptor": "1*mJEOJUxW51Vh-Y7cihnS0w.jpeg",
      "date": "Jun 4",
      "readTimeEstimate": "5 min"
    },
    {
      "id": 10,
      "blogId": 1,
      "userId": 1,
      "title": "How I learn an Open Source Codebase",
      "subTitle": "What I do to learn and understand an open source project to which I want to contribute.",
      "contentMarkup": "<p><strong>NOTE: This is a cross-post from <a href=\"http://kcd.im/news\" target=\"_blank\" rel=\"noopener noreferrer\">my newsletter</a>. I publish each email two weeks after it’s sent. Subscribe to get more content like this earlier right in your inbox! 💌</strong></p>\n  <p>Participating in open source has been awesome for me. It has made me and the stuff I make better. A common question that I get from folks is how to go about learning an open source codebase and understand other’s code.<br></p><p>In my blog post <a href=\"https://medium.com/@kentcdodds/open-source-stamina-dafd063f9932\" target=\"_blank\" rel=\"noopener noreferrer\">“Open Source Stamina”</a>, I make an important observation:</p><blockquote><b>You contribute best to something you use regularly.</b></blockquote>\n\n  <p>So while it can be a lot of fun to just jump into any open source project and help out. Sustainable contributions are best found in projects that you use on a regular basis. You have a better understanding of the use cases of the code which will help you understand the code better.</p><h3>Some steps</h3>\n  <p>Here’s a sequence of events I go through when I’m trying to learn or contribute to an open source project:</p><h4>Contributing Guidelines</h4><p>Look at the contributing guidelines first! This can be found in the <strike>README.md</strike> or a <strike>CONTRIBUTING.md</strike> file in the project. If it doesn’t exist, then file an issue and ask the maintainer to either make one or give you an idea of what they expect out of contributions.</p><h4>Project setup</h4><p>When you set up the project on your computer, make sure that you first install the dependencies and that the tests pass (if there are any). For JavaScript projects, you can mostly do:</p><ol><li>clone repo<br></li><li><strike>npm install</strike><br></li><li><strike>npm test</strike><br></li></ol><p>If all that works then you’re ready to go. The last thing you want to do is clone a repo with failing tests, make your change, and think that your change is the reason the tests are failing! This has happened to me :-(</p><h4>Follow the code</h4><p>Next, I try to follow the code in my head starting at the entry point where I’m interested in (like a function call, or a CLI with a certain argument). This can be intimidating for bigger projects, but it’s not as bad as you might think.</p><p>In my blogpost <a href=\"https://medium.com/@kentcdodds/what-open-source-project-should-i-contribute-to-7d50ecfe1cb4\" target=\"_blank\" rel=\"noopener noreferrer\">“What open source project should I contribute to?”</a> I talk a little bit about how to find where the code is for a specific API.</p><h4>Break things</h4><p>Reading and running the tests is also useful. Breaking things can also be a helpful way to learn a codebase.</p><h4>Log and step through</h4><p>It’s a tried and true debugging mechanism: <strike>console.log</strike> is a great way to learn a codebase. 👍 Even better if you can run it in the browser DevTools that’s also great. <a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\" target=\"_blank\" rel=\"noopener noreferrer\">Read more about NodeJS debugging in Chrome DevTools</a>.</p><p>One other thing you might try is running the project’s code in the context of your application. I talk about this a fair amount in my blog post from a few weeks ago <a href=\"https://blog.kentcdodds.com/spelunking-in-node-modules-bf165af19968\" target=\"_blank\" rel=\"noopener noreferrer\">“Spelunking in node_modules 👷”</a>.</p><h3>Conclusion</h3><p>Something else that I’ve found helpful is to ask someone on the project to walk me through some part of the code. I try to make it worth their time by offering to record our conversation and make it publicly available. This is appealing to maintainers because having material out there for new contributors to watch is very helpful. Here are some examples:</p><ul><li><a href=\"https://www.youtube.com/watch?v=crM1iRVGpGQ&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Why, What, and How of React Fiber with Dan Abramov and Andrew Clark</a><br></li><li><a href=\"https://www.youtube.com/watch?v=dRo_egw7tBc&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">React events in depth w/ Kent C. Dodds, Ben Alpert, &amp; Dan Abramov</a><br></li><li><a href=\"https://www.youtube.com/watch?v=i31VtyJSM-I&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript &amp; React Testing with Jest</a><br></li><li><a href=\"https://www.youtube.com/watch?v=wUpPsEcGsg8&amp;list=PLV5CVI1eNcJi8sor_aQ2AzOeQ3On3suOr\" target=\"_blank\" rel=\"noopener noreferrer\">Contributing to ReactJS</a><br></li></ul><p>I hope this is helpful! Good luck!<br></p>",
      "isLargePreview": false,
      "imgDescriptor": "1*NbePWo0hJrYA4mHeQBHmDw.jpeg",
      "date": "May 14",
      "readTimeEstimate": "4 min"
    }
  ],
  "revokedTokens": [
    {
      "id": "uuid - string",
      "token": "jwt - string"
    },
    {
      "id": "d84bc7bd-dd8d-4242-8b0c-bf36e3789572",
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaWF0IjoxNjU0MDgyNTE1LCJleHAiOjE2NTY2NzQ1MTV9.n2Ho45frT_9p3C7iK40TMjpuG4aK2aMq_WsIfh_DwMI"
    }
  ]
}